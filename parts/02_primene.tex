\section{Primene}
\label{sec:Primene}

Sinteza programa je moćan alat i mogućnosti primene su raznolike. Programski sintezeri se mogu naći u velikom broju današnjih aplikacija. Automatsko generisanje programskog koda čini proces programiranja manje repetitivnim i manje podložnim greškama. Moderni sintezeri omo\-gu\-ća\-va\-ju programerima da zadaju šablon koda ili nekoliko primera izlaza koda, dok se ceo kod generiše automatski. Ovaj proces se naziva \emph{Programiranje vođeno primerima} (eng. \emph{Programming Based on Examples)} \cite{ProgrammingBasedOnExamples} (u daljem tekstu \emph{PBE}).

Neke od oblasti primene sinteze programa koje će biti pokrivene u ovom radu su:
\begin{itemize}
    \item Priprema podataka
    \item Grafika
    \item Popravka koda
    \item Sugestije prilikom kodiranja
    \item Superoptimizacija
    \item Konkurentno programiranje
\end{itemize}


\subsection{Priprema podataka}
\label{subsec:PripremaPodataka}

\emph{Priprema podataka} predstavlja proces čišćenja, transformacije i pripreme podataka iz polu-struktuiranog formata u format pogodan za analizu i prezentovanje. Problem je skupoća dovođenja podataka u oblik pogodan za primenu algoritama iz oblasti mašinskog učenja ili istraživanja podataka radi izvlačenja korisnih zaključaka. PBE čini čitav ovaj proces bržim \cite{ProgrammingBasedOnExamples}.

Proces pripreme podataka često obuhvata sledeće korake:
\begin{itemize}
  \item izvlačenje
  \item transformacija
  \item formatiranje
\end{itemize}

Transformacija podataka se često svodi na manipulisanje niskama ili izmenama samih tipova podataka. Iako savremeni programski jezici pomažu korisnicima uvodeći širok spektar komandi, korisnici se zamaraju pisanjem skriptova ili makroa kako bi obavili posao. Alati koji koriste PBE su idealni za ovakav posao \cite{ProgrammingBasedOnExamples, SynthesizingNumberTransformationsFromIOExamples}


\subsection{Grafika}
\label{subsec:Grafika}

Programski opis grafičkih objekata dovodi do bržih proračuna koordinata zavisnih tačaka od tačaka koje imaju slobodne koordinate, što omogućava interaktivne izmene i efikasne animacije. Tehnike sinteze programa mogu uspešno generisati rešenja geometrijskih problema sre\-dnjo\-ško\-lske težine \cite{SynthesizingGeometryConstructions}.

Slike i crteži (u daljem tekstu \emph{grafike}) nekada sadrže ponovljene šablone, teksture ili objekte. Konstrukcija takvih grafika zahteva pisanje skriptova ili ponovljenih operacija, što može biti jako neprijatno i podložno greškama. Korišćenjem PBE, moguće je omogućiti korisniku da prikaže par primera i ostavi posao sintezeru da predvidi naredne objekte u nizu \cite{Backpropagation}. Štaviše, korišćenjem grafičkog interfejsa za domen vektorske grafike, moguće je interaktivno postavljati grafike isključivo pomoću grafičkih alata ili grafičkog interfejsa, a generisanje programskog koda ostaviti sintezeru.


\subsection{Popravka koda}
\label{subsec:PopravkaKoda}

Za dat program $P$ i specifikaciju $\phi$, problem popravke koda zahteva ra\-ču\-na\-nje modifikacija programa $P$ koje stvaraju nov program $P'$ takav da zadovoljava $\phi$. Osnovna ideja ovih tehnika je da se prvo ubace alternativni izbori za izraze u programu, a onda tehnikama programske sinteze izraza pronađu izrazi koji program dovode u oblik koji zadovoljava $\phi$. Postoji mnogo tehnika sinteze napravljenih specifično za problem popravke koda \cite{Qlose, ProgramRepairAsAGame}. Primer koda generisanog od strane programa \emph{SemFix} \cite{SemFix} se može videti na slici \ref{fig:CodeRepair}.

\begin{figure}[t]
    \centering
    \begin{tabular}{ccc|cc}
        \multicolumn{3}{c|}{Ulaz} & \multicolumn{2}{c}{Izlaz}\\
        inb & usep & dsep & expected & actual \\
        \hline
        1 & 0 & 100 & 0 & 0 \\
        1 & 11 & 110 & 1 & 0 \\
        0 & 100 & 50 & 1 & 1 \\
        1 & -20 & 60 & 1 & 0 \\
        0 & 0 & 10 & 0 & 0 \\
    \end{tabular}

    \centering
    \begin{lstlisting}[language=C]
        int buggy(int inb, int usep, int dsep)
        {
            int bias;
            if (inhb)
                bias = dsep; //fix: bias = usep+100
            else
                bias = usep;
            if (bias > dsep)
                return 1;
            else
                return 0;
        }
    \end{lstlisting}

    \caption{Primer koda sinteziranog od strane programa \emph{SemFix} \cite{SemFix} koristeći skup ulaznih i izlaznih test primera.}
    \label{fig:CodeRepair}
\end{figure}

\subsection{Sugestije prilikom kodiranja}
\label{subsec:SugestijePrilikomKodiranja}

Većina današnjih programerskih okruženja omogućava neku vrstu a\-u\-to\-ma\-tske dopune koda (npr. \emph{IntelliSense} za \emph{MS Visual Studio} ili \emph{Content Assist} za \emph{Eclipse}). Programski sintesizeri mogu potencijalno generisati ne samo tokene već i čitave jedinice koda. Dva najbitnija pristupa ovom problemu su \emph{statistički modeli} \cite{CCWSLM} i \emph{type-directed completion} \cite{TDCOPE}, ali je važno napomenuti da postoje i alati koji su uspešni iako ne koriste ove tehnike (npr. \emph{InSynth} \cite{IS} i \emph{Bing Developer Assistant} \cite{BDA}).


\subsection{Superoptimizacija}
\label{subsec:Superoptimizacija}

Superoptimizacija predstavlja proces kreiranja optimalnog poretka instrukcija mašinskog koda tako da je dobijeni fragment koda ekvivalentan polaznom uz dobijanje na performansama \cite{Superoptimizer}.

Kao primer, uzmimo računanje proseka dva broja $x$ i $y$. Formula $\mathit{prosek}=\frac{x+y}{2}$ može dovesti do prekoračenja. Takođe koristi skupu aritmetičku operaciju deljenja. Alternativa je formula $(x \mid y)-((x \oplus y) \gg 1)$. Ova formula koristi veoma brze bitovske operatore i operaciju oduzimanja, rešavajući probleme prethodne formule.

Jedan od načina da se kod automatski optimizuje je korišćenje  \emph{enumerativne pretrage} (videti sekciju \ref{subsubsec:Enumerative} na strani \pageref{subsubsec:Enumerative}), sa \emph{LENS} algoritmom kao predstavnikom \cite{ScalingUpSuperoptimization}.


\subsection{Konkurentno programiranje}
\label{subsec:KonkurentnoProgramiranje}

Sinteza programa se u oblasti konkurentnog programiranja koristi kao pomoć programerima u pisanju bezbednog kompleksnog koda. Postoji više tehnika sinteze koje u programski kod uspešno postavljaju minimalne konstrukte za sinhronizaciju. Predstavnik u ovom polju je \emph{Sinteza vođena apstrakcijom} (eng. \emph{Abstraction-Guided Synthesis)} (u daljem tekstu \emph{AGS})  \cite{AGS}.

AGS je tehnika kojom se program i njegova apstrakcija zajedno menjaju sve dok apstrakcija programa ne postane dovoljno precizna da ga verifikuje. AGS algoritam pravi apstraktnu reprezentaciju programa u apstraktnom domenu i proverava da li postoji prekršenje postavljene specifikacije programa. Specifikacija se obično vezuje za trku za podacima. Ukoliko postoji prekršenje specifikacije, AGS algoritam nedeterministički bira da li da menja apstrakciju (npr. sužavanjem domena) ili da menja sam program dodavajući sinhronizacione konstrukte. Ovaj postupak se ponavlja sve dok se ne nađe program koji može biti verifikovan apstrakcijom.
